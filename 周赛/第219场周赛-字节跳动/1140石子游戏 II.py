# 亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。
# 游戏以谁手中的石子最多来决出胜负。
# 亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。
# 在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 <= X <= 2M。
# 然后，令 M = max(M, X)。
# 游戏一直持续到所有石子都被拿走。
# 假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。

# 示例：
# 输入：piles = [2,7,9,4,4]
# 输出：10
# 解释：
# 如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。
# 在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。 
# 如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。
# 在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。
# 所以我们返回更大的 10。 



def stoneGameII(piles):
  # 动态规划
  # 定义:  
  # dp[i][m] 表示游戏的石子为piles[i,...n-1],M=m时当前选手所能拿走的石头的重量最大值 
  # 其中 0<=i<=n-1  1<=m<(n+1)//2 
  # 细节:当m=(n+1)//2时 便总能拿走所有石子 更大的m不会带来新的状态; 
  # 当前选手不一定是Alex,这个不影响,dp[0][m]对应的总是Alex

  # 初始化
  # dp[i][m]=post_sum[i] if i+2*m>=n-1
  # 其中 post_sum[i]=piles[i]+...+piles[n-1]

  # 迭代
  # if i+2*m>=n-1: dp[i][m] = post_sum[i]
  # else: dp[i][m] = max{post_sum[i]-dp[i+x][min(max(x,m),M)] | x=1,..,2m} 
  # 解释第二个式子: dp[i+x][min(max(x,m),M)]是下一个选手面临piless[i+x,...n-1]
  # 时能够拿走的最多的石子 其余的都是当前选手的 （当前选手不只是拿走了piles[i,...,i+x-1]共x个石子 
  # 再剩下的石子中可能也有份额 所以我们看下一个选手的最多石子 用全部的减去下一个选手的就是当前选手的）
  # 迭代顺序: 迭代公式指引我们如何去指定迭代顺序 这题的迭代顺序比较奇特 
  # 第二个迭代公式中 dp[i][] 可以从 dp[i+x][] (x>=1) 得来, 所以i从大到小, m 顺/逆 都行
  # 合理性: 这样倒着迭代, 我们计算dp[i][m]时, dp[i+1][1]...dp[i+1][M]都能够计算出来, 
  # 且初始行 dp[n-1][m]恒等于post_sum[n-1]因为m>=1

  

  # 记忆化搜索
  n = len(piles)
  memo = dict()

  # s[i]表示第i堆石子到最后一堆石子的总石子数
  s = [0] * (n + 1)
  for i in range(n - 1, -1, -1):
    s[i] = s[i + 1] + piles[i]

  # dfs(i, m)表示从第i堆石子开始取，最多能获取m堆石子所能得到的最优值
  def dfs(i, m):
    # 如果已经搜索过，则返回
    if(i, m) in memo:
      return memo[(i, m)]
    # 溢出拿不到任何石子
    if i >= n:
      return 0
    # 如果剩余堆数小于等于2m, 那么可以全拿走
    if i + m * 2 >= n:
      return s[i]
    # 枚举拿x堆的最优值
    best = 0
    for x in range(1, m * 2 + 1):
      # 剩余石子减去对方最优策略
      best = max(best, s[i] - dfs(i + x, max(x, m)))
    # 记忆化
    memo[(i, m)] = best
    return best
  
  return dfs(0, 1)

print(stoneGameII([2, 7, 9, 4, 4]))
