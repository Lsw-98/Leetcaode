import random

lst = [
  '将一个类的接口转成用户希望得到的接口。使原本不相容的接口得以协同工作。',
  '将类的抽象部分和现实部分分离开来，使他们可以独立的变化。',
  '将对象组合成树形结构，使用户对单个对象和组合对象的使用具有一致性。',
  '动态的给一个对象添加一些额外的职责。',
  '定义了一个高层接口，为子系统中的一组系统接口提供了一个一致外观，简化了系统的使用。',
  '提供支持大量细粒度对象共享的有效方法。',
  '为其他对象提供一种代理以控制这个对象的访问。',
  '定义一个创建对象的接口，但由于子类决定需要实例化哪一个类，工厂方法使得子类实例化的过程推迟。',
  '提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类。',
  '用原型实例指定创建对象的类型，并通过复制这个原型来创建新的对象。',
  '将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示。',
  '保证一个类只有一个实例，并提供一个访问它的全局访问点。',
  '通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接受对象链接起来，直到有对象处理这个请求。',
  '将一个请求封装为一个对象，将不同的请求封装为参数化，支持可撤销操作。',
  '定义一个解释器，该解释器用来根据文法表示解释语言中的句子。',
  '顺序访问一个聚合对象中的各个元素，不需要暴露该对象内部表示。',
  '用中介对象封装一系列对象交互。使各对象不需要显示调用，从而达到低耦合，还可以独立地改变对象之间的交互。',
  '不破坏封装的前提下，捕获对象内部的状态，在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态。',
  '定义对象之间一对多的依赖，当一个对象发生改变时，所有依赖它的对象都会得到通知并自动更新。',
  '允许一个对象在其内部状态改变时改变他的行为。',
  '定义一系列算法，把它们一个个封装起来，他们之间可以相互替换。',
  '定义一个操作中的算法骨架，将这些步骤延迟到子类中，使得子类可以不改变算法的结构即可重新定义算法的某些特定步骤。',
  '作用于某对象结构中的各元素操作，使得不改变各元素的类的前提下定义作用与这些元素的新操作。',
]

random.shuffle(lst)
[print(i, end='\n') for i in lst]