# 一个厨师收集了他 n 道菜的满意程度 satisfaction ，这个厨师做出每道菜的时间都是 1 单位时间。
# 一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 time[i]*satisfaction[i] 。
# 请你返回做完所有菜 「喜爱时间」总和的最大值为多少。
# 你可以按 任意 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。 

# 示例 1：
# 输入：satisfaction = [-1,-8,0,5,-9]
# 输出：14
# 解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。

# 示例 2：
# 输入：satisfaction = [4,3,2]
# 输出：20
# 解释：按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 = 20)

# 示例 3：
# 输入：satisfaction = [-1,-4,-5]
# 输出：0
# 解释：大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。

# 示例 4：
# 输入：satisfaction = [-2,5,-1,0,3,-3]
# 输出：35


def maxSatisfaction(satisfaction):
  '''
  官方题解
    我们从最简单的情况开始思考起。假设我们只能选一道菜，那么我们应该如何选择呢？显然，选择满意程度最大的那一道菜s0是最优的，
    并且我们需要验证是否有 s0 > 0，因为如果s0 ≤ 0，我们选择这道菜不会有任何受益。

    现在我们可以再多选一道菜，也就是两道菜，那么我们应该如何选择呢？假设我们选择了 s1这道菜，那么满意程度的总和为s1+2s0

    由于 s0是满意程度最大的那道菜，我们要最大化上述表达式的值，就应该找到尽可能大的 s1
    因此在最优的情况下，我们选择满意程度次大的那一道菜作为 s1，并且需要保证选择之后的收益多于选择之前的收益，即s1+2s0 > s0
    也就是要满足s1 + s0 > s0，这样我们就可以选择s1

    对于第三道菜也是一样选择满意程度第三大的那一道菜作为 s2，同时要保证收益的增加，即s2 + 2s1 + 3s0 > s1 + 2s0
    也就是当s2 + s1 + s0 > 0时，我们就可以选择 s2


    因此我们就有了一个贪心的大致思路:
    我们将所有菜的满意程度从大到小排序；
    我们按照排好序的顺序依次遍历这些菜，对于当前遍历到的菜 si，
    如果它与之前选择的所有菜的满意程度之和大于 0，我们就选择这道菜，否则可以直接退出遍历的循环。这是因为如果 si
    与之前选择的所有菜的满意程度之和已经小于等于 0 了，那么后面的菜比 si的满意程度还要小，就更不可能得到一个大于 0 的和了。
  '''

  satisfaction.sort(reverse=True)
  presum, ans = 0, 0
  for si in satisfaction:
      if presum + si > 0:
          presum += si
          ans += presum
      else:
          break
  return ans


print(maxSatisfaction([-1, -8, 0, 5, -9]))
print(maxSatisfaction([4, 3, 2]))
print(maxSatisfaction([-1, -4, -5]))
print(maxSatisfaction([-2, 5, -1, 0, 3, -3]))
