# 题目描述
# 学霸抢走了大家的作业，班长为了帮同学们找回作业，决定去找学霸决斗。但学霸为了不要别人打扰，住在一个城堡里，城堡外面是一个二维的格子迷宫，
# 要进城堡必须得先通过迷宫。因为班长还有妹子要陪，磨刀不误砍柴功，他为了节约时间，从线人那里搞到了迷宫的地图，准备提前计算最短的路线。
# 可是他现在正向妹子解释这件事情，于是就委托你帮他找一条最短的路线。

# 输入
# 第一行两个整数n， m，为迷宫的长宽。
# 接下来n行，每行m个数，数之间没有间隔，为0或1中的一个。0表示这个格子可以通过，1表示不可以。假设你现在已经在迷宫坐标(1, 1)的地方，
# 即左上角，迷宫的出口在(n, m)。每次移动时只能向上下左右4个方向移动到另外一个可以通过的格子里，每次移动算一步。数据保证(1, 1)，(n, m)可以通过

# 输出
# 第一行一个数为需要的最少步数K。
# 第二行K个字符，每个字符∈{U, D, L, R}, 分别表示上下左右。如果有多条长度相同的最短路径，选择在此表示方法下字典序最小的一个。

# 样例输入
# 3 3
# 001
# 100
# 110

# 样例输出
# 4
# RDRD


from collections import deque
# n, m = map(int, input().split())

# migong = []
# for i in range(n):
#     temp = input()
#     temp = list(map(int, temp))
#     migong.append(temp)

n, m = 3, 3
migong = [[0, 0, 1], [1, 0, 0], [1, 1, 0]]

G = [[''] * m for _ in range(n)]
q = deque([(0, 0)])

while q:
    x, y = q.popleft()
    if x == n - 1 and y == m - 1:
        print(len(G[-1][-1]))
        print(G[-1][-1])
        break
    for i, j, k in [(1, 0, 'D'), (0, -1, 'L'), (0, 1, "R"), (-1, 0, "U")]:
        a = x + i
        b = y + j
        if 0 <= a < n and 0 <= b < m and migong[a][b] == 0:
            migong[a][b] = 1
            q.append((a, b))
            G[a][b] = G[x][y] + k
